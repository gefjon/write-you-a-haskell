(in-package :write-you-a-haskell)

(defmacro defexpr (expr-name slots &key (documentation "generated by WRITE-YOU-A-HASKELL:DEFEXPR"))
  "e.g. (DEFEXPR let ((binding symbol) (initializer expression) (body expression)))"
  (let ((slot-names (gefjon-utils:slot-descriptors-names slots)))
    `(gefjon-utils:compiler-state
       (gefjon-utils:defstruct ,expr-name ,slots :documentation ,documentation)
       (defmethod print-object ((this ,expr-name) stream)
         (with-slots ,slot-names this
           (format stream "(~s~@{ ~s~})" ',expr-name ,@slot-names)))

       (defmacro ,expr-name ,(concatenate 'list slot-names '(&environment env))
         (,(gefjon-utils:constructor-name expr-name)
          ,@(flet ((macroexpand-form (form)
                     (list 'macroexpand form 'env)))
              (mapcar #'macroexpand-form slot-names))))

       (defmethod make-load-form ((expr ,expr-name) &optional environment)
         (make-load-form-saving-slots expr :environment environment)))))

(defmacro defenum (type-name &rest variants)
  (flet ((define-variant (variant)
           (etypecase variant
             (symbol nil)
             (list `(defexpr ,@variant
                      :documentation "variant generated by WRITE-YOU-A-HASKELL:DEFENUM"))))
         (type-name-for (variant)
           (the symbol
                (etypecase variant
                  (symbol variant)
                  (list (first variant))))))
    `(gefjon-utils:compiler-state
       ,@(mapcar #'define-variant variants)
       (deftype ,type-name ()
         '(or ,@(mapcar #'type-name-for variants))))))
